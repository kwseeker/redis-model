# Redis场景问题&解决

+ 缓存穿透
+ 缓存击穿（缓存失效）
+ 缓存雪崩
+ 数据库与缓存一致性问题
  + cache-aside
  + read-through 
  + write-through
  + write-behind
  + refresh-ahead

+ 热key缓存过期后重建问题



## 缓存穿透

缓存穿透是指查询**在缓存层和数据层根本不存在的数据**， 缓存层和存储层都不会命中。将导致不存在的数据**每次请求**都要到存储层去查询， 失去了缓存保护后端存储的意义。

产生原因：

+ 恶意攻击、爬虫等
+ 代码bug或数据丢失等（可能性较小）

解决方案：

+ 缓存空对象

  不太好，如果请求的键都不一样会浪费大量空间。

+ 布隆过滤器

  每次查到不存在的数据就往布隆过滤器中记录一下，可以在查询缓存前让布隆过滤器先过滤一遍，

  > 布隆过滤器实现原理参考Redisson中的实现。

## 缓存失效（缓存击穿）

由于大批量缓存在同一时间失效可能导致大量请求同时穿透缓存直达数据库，可能会造成数据库瞬间压力过大 甚至挂掉。

解决方案：

+ 避免大量缓存在同一时间失效

## 缓存雪崩

缓存雪崩指的是缓存层支撑不住或宕掉后， 流量全部打到后端存储层。

解决方案：

+ 保证缓存层服务高可用性
+ 使用限流降级组件为后端限流熔断并降级
+ 对于一些大促类活动提前做演练评估和优化系统性能

## 数据库与缓存双写一致性问题

解决方案：

+ 一般对于并发不高、对一致性要求不高的业务直接采用Cache-Aside模式更新即可，先更新数据库再删除缓存。更可靠一点的可以使用延迟双删，就是在Cache-Aside模式基础上等一小段时间后再删一次。

+ 如果零容忍数据不一致性可以加锁，如读写锁。

+ 也可以监听数据库binlog日志顺序修改缓存。

## 热key缓存过期后重建问题

记录缓存时一般都会设置过期时间，大部分情况这样使用是没有问题的，但是如果这个key是热key，**请求量一直很大且重建时间较长**，一旦缓存过期删除，大量请求打到数据库很可能导致应用崩溃。

解决方案：

+ 借鉴分布式锁，可以设置一个看门狗线程，如果是热key可以定时续约，也可以参考jd-hotkey的实现。

